; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc -mtriple=amdgcn -mcpu=gfx1010 -verify-machineinstrs < %s | FileCheck %s -check-prefix=GCN

define amdgpu_ps float @while_break(i32 %z, float %v, i32 %x, i32 %y) #0 {
; GCN-LABEL: while_break:
; GCN:       ; %bb.0: ; %entry
; GCN-NEXT:    s_mov_b32 s0, -1
; GCN-NEXT:    s_mov_b32 s1, 0
; GCN-NEXT:    s_branch .LBB0_2
; GCN-NEXT:  .LBB0_1: ; %Flow2
; GCN-NEXT:    ; in Loop: Header=BB0_2 Depth=1
; GCN-NEXT:    s_and_b32 s2, exec_lo, s2
; GCN-NEXT:    s_or_b32 s1, s2, s1
; GCN-NEXT:    s_andn2_b32 s2, exec_lo, s1
; GCN-NEXT:    s_cselect_b32 exec_lo, s2, s1
; GCN-NEXT:    s_cbranch_scc0 .LBB0_8
; GCN-NEXT:  .LBB0_2: ; %header
; GCN-NEXT:    ; =>This Inner Loop Header: Depth=1
; GCN-NEXT:    s_add_i32 s0, s0, 1
; GCN-NEXT:    s_mov_b32 s2, 0
; GCN-NEXT:    v_cmp_ge_i32_e32 vcc_lo, s0, v2
; GCN-NEXT:    s_xor_b32 s3, vcc_lo, exec_lo
; GCN-NEXT:    s_cmp_lg_u32 vcc_lo, 0
; GCN-NEXT:    s_cmov_b32 exec_lo, vcc_lo
; GCN-NEXT:    s_cbranch_scc0 .LBB0_4
; GCN-NEXT:  ; %bb.3: ; %else
; GCN-NEXT:    ; in Loop: Header=BB0_2 Depth=1
; GCN-NEXT:    v_cmp_lt_i32_e32 vcc_lo, s0, v3
; GCN-NEXT:    s_and_b32 s2, vcc_lo, exec_lo
; GCN-NEXT:    s_or_b32 exec_lo, exec_lo, s3
; GCN-NEXT:  .LBB0_4: ; %Flow
; GCN-NEXT:    ; in Loop: Header=BB0_2 Depth=1
; GCN-NEXT:    s_xor_b32 s4, s3, exec_lo
; GCN-NEXT:    s_cmp_lg_u32 s3, 0
; GCN-NEXT:    s_cmov_b32 exec_lo, s3
; GCN-NEXT:    s_cbranch_scc0 .LBB0_6
; GCN-NEXT:  ; %bb.5: ; %if
; GCN-NEXT:    ; in Loop: Header=BB0_2 Depth=1
; GCN-NEXT:    v_add_f32_e32 v1, 1.0, v1
; GCN-NEXT:    s_or_b32 s2, s2, exec_lo
; GCN-NEXT:    s_or_b32 exec_lo, exec_lo, s4
; GCN-NEXT:  .LBB0_6: ; %Flow1
; GCN-NEXT:    ; in Loop: Header=BB0_2 Depth=1
; GCN-NEXT:    s_mov_b32 s3, exec_lo
; GCN-NEXT:    s_and_b32 s4, s2, exec_lo
; GCN-NEXT:    s_mov_b32 s2, -1
; GCN-NEXT:    s_cmov_b32 exec_lo, s4
; GCN-NEXT:    s_cbranch_scc0 .LBB0_1
; GCN-NEXT:  ; %bb.7: ; %latch
; GCN-NEXT:    ; in Loop: Header=BB0_2 Depth=1
; GCN-NEXT:    v_cmp_lt_i32_e32 vcc_lo, s0, v0
; GCN-NEXT:    s_orn2_b32 s2, vcc_lo, exec_lo
; GCN-NEXT:    s_or_b32 exec_lo, exec_lo, s3
; GCN-NEXT:    s_branch .LBB0_1
; GCN-NEXT:  .LBB0_8: ; %end
; GCN-NEXT:    v_mov_b32_e32 v0, v1
; GCN-NEXT:    ; return to shader part epilog
entry:
  br label %header

header:
  %v.1 = phi float [ %v, %entry ], [ %v.2, %latch ]
  %ind = phi i32 [ 0, %entry], [ %ind.inc, %latch ]
  %cc = icmp slt i32 %ind, %x
  br i1 %cc, label %if, label %else

if:
  %v.if = fadd float %v.1, 1.0
  br label %latch

else:
  %cc2 = icmp slt i32 %ind, %y
  br i1 %cc2, label %latch, label %end

latch:
  %v.2 = phi float [ %v.if, %if ], [ %v.1, %else ]
  %ind.inc = add i32 %ind, 1
  %cc3 = icmp slt i32 %ind, %z
  br i1 %cc3, label %end, label %header

end:
  %r = phi float [ %v.2, %latch ], [ %v.1, %else ]
  ret float %r
}

; Just different dfs order from while_break.
define amdgpu_ps float @while_break2(i32 %z, float %v, i32 %x, i32 %y) #0 {
; GCN-LABEL: while_break2:
; GCN:       ; %bb.0: ; %entry
; GCN-NEXT:    s_mov_b32 s0, -1
; GCN-NEXT:    s_mov_b32 s1, 0
; GCN-NEXT:    s_branch .LBB1_2
; GCN-NEXT:  .LBB1_1: ; %Flow2
; GCN-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; GCN-NEXT:    s_and_b32 s2, exec_lo, s2
; GCN-NEXT:    s_or_b32 s1, s2, s1
; GCN-NEXT:    s_andn2_b32 s2, exec_lo, s1
; GCN-NEXT:    s_cselect_b32 exec_lo, s2, s1
; GCN-NEXT:    s_cbranch_scc0 .LBB1_8
; GCN-NEXT:  .LBB1_2: ; %header
; GCN-NEXT:    ; =>This Inner Loop Header: Depth=1
; GCN-NEXT:    s_add_i32 s0, s0, 1
; GCN-NEXT:    s_mov_b32 s2, 0
; GCN-NEXT:    v_cmp_ge_i32_e32 vcc_lo, s0, v2
; GCN-NEXT:    s_xor_b32 s3, vcc_lo, exec_lo
; GCN-NEXT:    s_cmp_lg_u32 vcc_lo, 0
; GCN-NEXT:    s_cmov_b32 exec_lo, vcc_lo
; GCN-NEXT:    s_cbranch_scc0 .LBB1_4
; GCN-NEXT:  ; %bb.3: ; %if
; GCN-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; GCN-NEXT:    v_add_f32_e32 v1, 1.0, v1
; GCN-NEXT:    s_mov_b32 s2, exec_lo
; GCN-NEXT:    s_or_b32 exec_lo, exec_lo, s3
; GCN-NEXT:  .LBB1_4: ; %Flow
; GCN-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; GCN-NEXT:    s_xor_b32 s4, s3, exec_lo
; GCN-NEXT:    s_cmp_lg_u32 s3, 0
; GCN-NEXT:    s_cmov_b32 exec_lo, s3
; GCN-NEXT:    s_cbranch_scc0 .LBB1_6
; GCN-NEXT:  ; %bb.5: ; %else
; GCN-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; GCN-NEXT:    v_cmp_lt_i32_e32 vcc_lo, s0, v3
; GCN-NEXT:    s_andn2_b32 s2, s2, exec_lo
; GCN-NEXT:    s_and_b32 s3, vcc_lo, exec_lo
; GCN-NEXT:    s_or_b32 s2, s2, s3
; GCN-NEXT:    s_or_b32 exec_lo, exec_lo, s4
; GCN-NEXT:  .LBB1_6: ; %Flow1
; GCN-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; GCN-NEXT:    s_mov_b32 s3, exec_lo
; GCN-NEXT:    s_and_b32 s4, s2, exec_lo
; GCN-NEXT:    s_mov_b32 s2, -1
; GCN-NEXT:    s_cmov_b32 exec_lo, s4
; GCN-NEXT:    s_cbranch_scc0 .LBB1_1
; GCN-NEXT:  ; %bb.7: ; %latch
; GCN-NEXT:    ; in Loop: Header=BB1_2 Depth=1
; GCN-NEXT:    v_cmp_lt_i32_e32 vcc_lo, s0, v0
; GCN-NEXT:    s_orn2_b32 s2, vcc_lo, exec_lo
; GCN-NEXT:    s_or_b32 exec_lo, exec_lo, s3
; GCN-NEXT:    s_branch .LBB1_1
; GCN-NEXT:  .LBB1_8: ; %end
; GCN-NEXT:    v_mov_b32_e32 v0, v1
; GCN-NEXT:    ; return to shader part epilog
entry:
  br label %header

header:
  %v.1 = phi float [ %v, %entry ], [ %v.2, %latch ]
  %ind = phi i32 [ 0, %entry], [ %ind.inc, %latch ]
  %cc = icmp slt i32 %ind, %x
  br i1 %cc, label %else, label %if

if:
  %v.if = fadd float %v.1, 1.0
  br label %latch

else:
  %cc2 = icmp slt i32 %ind, %y
  br i1 %cc2, label %latch, label %end

latch:
  %v.2 = phi float [ %v.if, %if ], [ %v.1, %else ]
  %ind.inc = add i32 %ind, 1
  %cc3 = icmp slt i32 %ind, %z
  br i1 %cc3, label %end, label %header

end:
  %r = phi float [ %v.2, %latch ], [ %v.1, %else ]
  ret float %r
}

attributes #0 = { nounwind }
